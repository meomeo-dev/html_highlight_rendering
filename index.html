<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<!-- region åºç« ï¼šé¡µé¢å…ƒä¿¡æ¯ä¸æ•´ä½“æ ·å¼ -->
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Markdown é«˜äº®æ¸²æŸ“å™¨ Â· å•æ–‡ä»¶ SPA</title>
	<style>
		/* region åŸºç¡€æ ·å¼ï¼ˆæ’ç‰ˆä¸å¸ƒå±€ï¼‰ */
		:root {
			--bg: #0b1016;
			--panel: #121824;
			--text: #e6edf3;
			--muted: #9fb0c8;
			--accent: #7cc0ff;
			--accent-2: #a8ffcc;
			--danger: #ff7a7a;
			--warning: #ffc658;
			--mark-bg: #ffee99;
			--mark-fg: #242424;
			--border: #1e293b;
			/* W&Bï¼ˆWeights & Biasesï¼‰é£æ ¼ä¸»è‰²ï¼šé«˜å¯¹æ¯”é»„ä¸å¢¨è‰²æ–‡å­— */
			--wb-yellow: #ffbe00;
			--wb-yellow-hover: #ffcc33;
			--wb-yellow-active: #e5ad00;
			--wb-ink: #111111;
			/* é¢å¤–è¡¨é¢è‰²ï¼ˆä¸ºåˆ‡æ¢ä¸»é¢˜æä¾›è¦†ç›–ç‚¹ï¼‰ */
			--surface-1: #0f1625;
			/* è½»é¢æ¿ã€æ¡ç›®åº•è‰² */
			--surface-2: #0b1323;
			/* ä»£ç å—ã€å¼ºè°ƒåº•è‰² */
		}

		/* äº®è‰²ä¸»é¢˜è¦†ç›– */
		html[data-theme="light"] {
			--bg: #f6f8fa;
			--panel: #ffffff;
			--text: #111827;
			--muted: #6b7280;
			--accent: #2563eb;
			--accent-2: #059669;
			--danger: #dc2626;
			--warning: #d97706;
			--mark-bg: #fff2a8;
			--mark-fg: #111827;
			--border: #e5e7eb;
			--surface-1: #f3f4f6;
			--surface-2: #f8fafc;
		}

		* {
			box-sizing: border-box;
		}

		html,
		body {
			height: 100%;
		}

		body {
			margin: 0;
			background: linear-gradient(180deg, #0b1016 0%, #0e1420 100%);
			color: var(--text);
			font: 14px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
				Noto Sans, Ubuntu, Cantarell, Helvetica Neue, Arial, "PingFang SC",
				"Hiragino Sans GB", "Microsoft YaHei", sans-serif;
		}

		/* äº®è‰²ä¸»é¢˜ä¸‹çš„é¡µé¢èƒŒæ™¯ï¼ˆä½¿ç”¨æ›´æµ…çš„æ¸å˜ï¼‰ */
		html[data-theme="light"] body {
			background: linear-gradient(180deg, #f7fafc 0%, #f9fbfd 100%);
		}

		/* ä¸»é¢˜åˆ‡æ¢çš„å¹³æ»‘è¿‡æ¸¡ */
		body,
		header,
		.panel,
		.file,
		.button,
		.icon-btn,
		.quote-item,
		.pill,
		.doc code,
		.doc pre,
		.doc a,
		.doc h2,
		.doc h3,
		.legend,
		.brand,
		.hint {
			transition: background-color .3s ease, color .3s ease, border-color .3s ease, box-shadow .3s ease, opacity .25s ease;
		}

		.app {
			/* Long page layout: let body scroll, no fixed footer/header rows */
			display: block;
		}

		header {
			border-bottom: 1px solid var(--border);
			background: rgba(18, 24, 36, 0.9);
			backdrop-filter: saturate(120%) blur(8px);
			position: static;
			/* not sticky */
		}

		.toolbar {
			max-width: 1200px;
			margin: 0 auto;
			padding: 12px 16px;
			display: flex;
			align-items: center;
			gap: 12px;
			flex-wrap: wrap;
		}

		.brand {
			font-weight: 700;
			letter-spacing: 0.2px;
			color: var(--accent);
			margin-right: 8px;
		}

		.hint {
			color: var(--muted);
		}

		.file {
			display: inline-flex;
			align-items: center;
			gap: 8px;
			padding: 8px 10px;
			background: var(--surface-1);
			border: 1px solid var(--border);
			border-radius: 8px;
		}

		.file input[type="file"] {
			color: var(--muted);
		}

		.button {
			appearance: none;
			border: 1px solid var(--border);
			background: var(--surface-1);
			color: var(--text);
			padding: 8px 12px;
			border-radius: 8px;
			cursor: pointer;
		}

		/* é«˜å¯è§åº¦ï¼šW&B é£æ ¼æŒ‰é’®ï¼ˆçº¯è‰²ã€éæ¸å˜ï¼‰ */
		.button.wb {
			background: var(--wb-yellow);
			color: var(--wb-ink);
			border-color: #8a5d00;
			/* ä¸é»„ç›¸è¿‘çš„æ·±è‰²æè¾¹ï¼Œå¢å¼ºåˆ†å±‚ */
			font-weight: 700;
			letter-spacing: 0.2px;
		}

		.button.wb:hover {
			background: var(--wb-yellow-hover);
		}

		.button.wb:active {
			background: var(--wb-yellow-active);
		}

		.button.wb:focus-visible {
			outline: 2px solid #ffd466;
			outline-offset: 2px;
		}

		/* ç¨å¤§çš„å°ºå¯¸ï¼Œæå‡æ˜¾çœ¼åº¦ */
		.button.lg {
			padding: 10px 16px;
			font-size: 14px;
		}

		.button.primary {
			background: linear-gradient(90deg, #2563eb, #7c3aed);
			border-color: transparent;
			color: #ffffff;
			/* åœ¨äº®/æš—ä¸¤ç§ä¸»é¢˜ä¸‹éƒ½ä¿æŒé«˜å¯¹æ¯”åº¦ */
			text-shadow: 0 1px 0 rgba(0, 0, 0, 0.15);
		}

		.button.primary:hover {
			filter: brightness(1.05);
		}

		.button.primary:active {
			filter: brightness(0.95);
		}

		.button:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}

		/* å›¾æ ‡æŒ‰é’®ï¼ˆGitHubï¼‰ */
		.icon-btn {
			appearance: none;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			width: 32px;
			height: 32px;
			border-radius: 8px;
			border: 1px solid var(--border);
			background: var(--surface-1);
			color: var(--wb-yellow);
			text-decoration: none;
			cursor: pointer;
		}

		.icon-btn:hover {
			background: var(--panel);
		}

		.icon-btn:focus-visible {
			outline: 2px solid #ffd466;
			outline-offset: 2px;
		}

		/* ä¸»é¢˜æŒ‰é’®ï¼šå¤ªé˜³/æœˆäº®å›¾æ ‡åˆ‡æ¢ä¸åŠ¨æ•ˆ */
		.theme-toggle {
			color: var(--wb-yellow);
			position: relative;
			overflow: hidden;
		}

		.theme-toggle svg {
			display: block;
			width: 18px;
			height: 18px;
			transition: transform .45s ease, opacity .25s ease;
		}

		.theme-toggle .sun {
			position: absolute;
			opacity: 0;
			transform: rotate(-90deg) scale(.8);
		}

		.theme-toggle .moon {
			position: absolute;
			opacity: 1;
			transform: rotate(0) scale(1);
		}

		html[data-theme="light"] .theme-toggle .sun {
			opacity: 1;
			transform: rotate(0) scale(1);
		}

		html[data-theme="light"] .theme-toggle .moon {
			opacity: 0;
			transform: rotate(90deg) scale(.8);
		}

		.theme-toggle:active {
			transform: scale(0.96);
		}

		.main {
			display: grid;
			grid-template-columns: 320px 1fr;
			gap: 16px;
			max-width: 1200px;
			margin: 0 auto;
			padding: 16px;
			min-height: 0;
			/* for proper child scrolling */
		}

		.panel {
			background: var(--panel);
			border: 1px solid var(--border);
			border-radius: 12px;
			padding: 12px;
			min-height: 0;
		}

		.side {
			display: grid;
			grid-template-rows: auto 1fr;
			gap: 12px;
		}

		.meta {
			display: grid;
			gap: 8px;
		}

		.kv {
			display: grid;
			grid-template-columns: 96px 1fr;
			gap: 6px;
		}

		.kv .k {
			color: var(--muted);
		}

		.list {
			overflow: auto;
			display: grid;
			gap: 10px;
		}

		.quote-item {
			background: #0f1625;
			border: 1px solid var(--border);
			border-radius: 10px;
			padding: 10px;
			display: grid;
			gap: 6px;
		}

		.quote-item .q {
			color: var(--text);
		}

		/* è®©éè‹±æ–‡é•¿è¯/URL åœ¨ä¾§æ å¯æ¢è¡Œï¼Œé¿å…æº¢å‡º */
		.quote-item .q {
			word-break: break-word;
			/* å…¼å®¹æ€§è¾ƒå¥½ï¼Œå¿…è¦æ—¶åœ¨è¾¹ç•Œæ–­è¯ */
			overflow-wrap: anywhere;
			/* ä¼˜å…ˆï¼šå…è®¸ä»»æ„ä½ç½®æ¢è¡Œï¼ˆæ”¯æŒé•¿ URLï¼‰*/
			white-space: normal;
			/* ç¡®ä¿æ­£å¸¸æ¢è¡Œè¡Œä¸º */
		}

		.quote-item .sub {
			color: var(--muted);
			font-size: 12px;
		}

		.quote-item .actions {
			display: flex;
			gap: 6px;
		}

		/* type è‰²å—ä¸æ ‡ç­¾ */
		.dot {
			width: 10px;
			height: 10px;
			border-radius: 50%;
			border: 1px solid var(--border);
			display: inline-block;
		}

		.badge {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			padding: 2px 8px;
			border-radius: 999px;
			border: 1px solid var(--border);
			background: var(--surface-1);
			font-size: 12px;
			color: var(--muted);
		}

		/* åœ¨å¾½ç« ä¸­çš„å¼ºè°ƒæ ‡ç­¾ï¼Œä½¿ç”¨æ­£æ–‡è‰²ä»¥ä¿è¯å¯¹æ¯”åº¦ */
		.badge .label-strong {
			color: var(--text);
			font-weight: 600;
		}

		/* ç»Ÿä¸€äº¤äº’æ§ä»¶çš„ä¸»é¢˜è‰² */
		input[type="range"],
		input[type="checkbox"],
		input[type="radio"] {
			accent-color: var(--accent);
		}

		.content {
			/* Use document scrolling instead of inner container */
			overflow: visible;
		}

		.doc {
			max-width: 900px;
			margin: 0 auto;
			padding: 4px 8px 80px;
		}

		.doc h1,
		.doc h2,
		.doc h3 {
			scroll-margin-top: 84px;
		}

		.doc h1 {
			font-size: 28px;
			margin: 16px 0 12px;
		}

		.doc h2 {
			font-size: 22px;
			margin: 18px 0 10px;
			color: #bcd7ff;
		}

		.doc h3 {
			font-size: 18px;
			margin: 16px 0 8px;
			color: #c6ffe2;
		}

		.doc p {
			margin: 10px 0;
		}

		.doc a {
			color: var(--accent);
			text-decoration: none;
		}

		.doc a:hover {
			text-decoration: underline;
		}

		.doc code {
			background: var(--surface-2);
			padding: 2px 6px;
			border-radius: 6px;
		}

		.doc pre {
			background: var(--surface-2);
			padding: 12px;
			border-radius: 10px;
			overflow: auto;
		}

		.doc blockquote {
			border-left: 3px solid #2a3956;
			padding-left: 10px;
			color: #c0c9d6;
		}

		mark.hl {
			background: var(--mark-bg);
			color: var(--mark-fg);
			padding: 1px 0;
			border-radius: 4px;
			/* Ensure anchored scroll leaves space for the header */
			scroll-margin-top: 84px;
		}

		.legend {
			display: flex;
			gap: 8px;
			align-items: center;
			color: var(--muted);
		}

		.pill {
			display: inline-flex;
			align-items: center;
			gap: 6px;
			padding: 2px 8px;
			border-radius: 999px;
			border: 1px solid var(--border);
			background: #0f1625;
		}

		.pill {
			background: var(--surface-1);
		}

		/* äº®è‰²ä¸»é¢˜çš„å±€éƒ¨è¦†ç›–ï¼ˆé’ˆå¯¹ä»ä¸ºæ·±è‰²çš„å›ºå®šè‰²ï¼‰ */
		html[data-theme="light"] .quote-item {
			background: #ffffff;
		}

		html[data-theme="light"] .doc h2 {
			color: #1f2937;
		}

		html[data-theme="light"] .doc h3 {
			color: #065f46;
		}

		html[data-theme="light"] header {
			background: rgba(255, 255, 255, 0.9);
		}

		html[data-theme="light"] .icon-btn:hover {
			background: #f3f4f6;
		}

		/* footer å·²ç§»é™¤ */

		.error {
			color: var(--danger);
		}

		.ok {
			color: var(--accent-2);
		}

		@media (max-width: 960px) {
			.main {
				grid-template-columns: 1fr;
			}
		}

		/* endregion */
	</style>
	<!-- endregion -->
</head>

<body>
	<!-- ç¬¬ä¸‰æ–¹åº“ï¼šMarkedï¼ˆMarkdown æ¸²æŸ“ï¼‰ä¸ DOMPurifyï¼ˆå¯é€‰ï¼šå®‰å…¨æ¸…ç†ï¼‰ -->
	<script src="https://cdn.jsdelivr.net/npm/marked@16.4.1/lib/marked.umd.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/dompurify@3.3.0/dist/purify.min.js"></script>
	<!-- region ç¬¬ä¸€ç« ï¼šåº”ç”¨å…¥å£ä¸ä¸»æµç¨‹ï¼ˆTop-Down Narrativeï¼‰ -->
	<div class="app" id="app">
		<header>
			<div class="toolbar">
				<div class="brand">Markdown é«˜äº®æ¸²æŸ“å™¨</div>
				<div class="hint">å•æ–‡ä»¶ Â· ç¦»çº¿å¯ç”¨ Â· æ¸è¿›æš´éœ²</div>

				<div class="file" title="é€‰æ‹© Markdown æºæ–‡ä»¶ (.md)">
					<label>æºæ–‡æ¡£ (.md)</label>
					<input type="file" id="mdInput" accept=".md,.markdown,.txt" />
				</div>

				<div class="file" title="é€‰æ‹©é«˜äº®é…ç½®æ–‡ä»¶ (.yaml)">
					<label>é«˜äº®æ–‡ä»¶ (.yaml)</label>
					<input type="file" id="yamlInput" accept=".yaml,.yml" />
				</div>

				<a class="button wb lg" href="highlight.prompt.md" download
					title="ä¸‹è½½ç”¨äºç”Ÿæˆé«˜äº®çš„æç¤ºè¯æ¨¡æ¿ï¼ˆhighlight.prompt.mdï¼‰">ä¸‹è½½æç¤ºè¯</a>

				<label class="badge" title="ä»…å¯¹æœªå‘½ä¸­çš„æ¡ç›®å°è¯•æ¨¡ç³ŠåŒ¹é…ï¼ˆç¼–è¾‘è·ç¦»é˜ˆå€¼çº¦ 15%ï¼‰" style="cursor:pointer;">
					<input type="checkbox" id="fuzzyToggle" style="margin-right:6px; accent-color:#7cc0ff;"> æ¨¡ç³ŠåŒ¹é…
				</label>

				<label class="badge" title="ç¼–è¾‘è·ç¦»é˜ˆå€¼ï¼ˆå å¼•æ–‡é•¿åº¦æ¯”ä¾‹ï¼‰ï¼Œä»…åœ¨å¯ç”¨æ¨¡ç³ŠåŒ¹é…æ—¶ç”Ÿæ•ˆ" style="gap:6px; align-items:center;">
					<span class="label-strong">é˜ˆå€¼</span>
					<input type="range" id="fuzzySlider" min="0.0" max="1.0" step="0.01" value="0.15"
						style="vertical-align:middle; width:120px;">
					<span id="fuzzyVal">15%</span>
				</label>

				<button class="button" id="clearBtn">æ¸…é™¤é«˜äº®</button>
				<button class="button primary" id="runBtn" disabled>æ¸²æŸ“å¹¶é«˜äº®</button>

				<a class="icon-btn" href="https://github.com/meomeo-dev/html_highlight_rendering" target="_blank"
					rel="noopener noreferrer" aria-label="æ‰“å¼€ GitHub ä»“åº“" title="æ‰“å¼€ GitHub ä»“åº“">
					<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
						aria-hidden="true" focusable="false">
						<path fill="currentColor"
							d="M12 2C6.48 2 2 6.58 2 12.26c0 4.52 2.87 8.35 6.84 9.7.5.09.68-.22.68-.49 0-.24-.01-.87-.01-1.71-2.78.61-3.37-1.2-3.37-1.2-.45-1.18-1.11-1.5-1.11-1.5-.91-.64.07-.63.07-.63 1 .07 1.53 1.06 1.53 1.06.9 1.57 2.36 1.12 2.94.85.09-.67.35-1.12.63-1.38-2.22-.26-4.55-1.14-4.55-5.07 0-1.12.39-2.03 1.03-2.74-.1-.26-.45-1.31.1-2.72 0 0 .84-.27 2.75 1.04a9.29 9.29 0 0 1 2.5-.34c.85 0 1.7.12 2.5.34 1.91-1.31 2.75-1.04 2.75-1.04.55 1.41.2 2.46.1 2.72.64.71 1.03 1.62 1.03 2.74 0 3.94-2.34 4.81-4.57 5.07.36.32.68.95.68 1.92 0 1.38-.01 2.49-.01 2.83 0 .27.18.59.69.49A10.03 10.03 0 0 0 22 12.26C22 6.58 17.52 2 12 2z" />
					</svg>
				</a>

				<!-- ä¸»é¢˜åˆ‡æ¢æŒ‰é’®ï¼šæœˆäº®/å¤ªé˜³ -->
				<button class="icon-btn theme-toggle" id="themeToggle" aria-label="åˆ‡æ¢ä¸»é¢˜" title="åˆ‡æ¢ä¸»é¢˜ï¼ˆäº®/æš—ï¼‰">
					<!-- æœˆäº®ï¼ˆæš—è‰²åå¥½æ—¶æ˜¾ç¤ºï¼‰ -->
					<svg class="moon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
						aria-hidden="true">
						<path fill="currentColor" d="M21 12.79A9 9 0 1 1 11.21 3a7 7 0 1 0 9.79 9.79z" />
					</svg>
					<!-- å¤ªé˜³ï¼ˆäº®è‰²åå¥½æ—¶æ˜¾ç¤ºï¼‰ -->
					<svg class="sun" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"
						aria-hidden="true">
						<circle cx="12" cy="12" r="4" fill="currentColor" />
						<g stroke="currentColor" stroke-width="2" stroke-linecap="round">
							<line x1="12" y1="2" x2="12" y2="5" />
							<line x1="12" y1="19" x2="12" y2="22" />
							<line x1="4.22" y1="4.22" x2="6.34" y2="6.34" />
							<line x1="17.66" y1="17.66" x2="19.78" y2="19.78" />
							<line x1="2" y1="12" x2="5" y2="12" />
							<line x1="19" y1="12" x2="22" y2="12" />
							<line x1="4.22" y1="19.78" x2="6.34" y2="17.66" />
							<line x1="17.66" y1="6.34" x2="19.78" y2="4.22" />
						</g>
					</svg>
				</button>

				<div class="legend" style="margin-left:auto">
					<span class="pill">å·²åŠ è½½: <span id="mdName">æ— </span></span>
					<span class="pill">é«˜äº®: <span id="yamlName">æ— </span></span>
					<span class="pill" id="status">å¾…å‘½ä¸­â€¦</span>
				</div>
			</div>
		</header>

		<main class="main">
			<aside class="side">
				<section class="panel meta">
					<div class="kv">
						<div class="k">æ–‡æ¡£ ID</div>
						<div id="docId">â€”</div>
					</div>
					<div class="kv">
						<div class="k">è¯­è¨€</div>
						<div id="docLang">â€”</div>
					</div>
					<div class="kv">
						<div class="k">åˆ›å»ºæ—¶é—´</div>
						<div id="docCreated">â€”</div>
					</div>
					<div class="kv">
						<div class="k">åŒ¹é…ç»“æœ</div>
						<div id="matchStats">â€”</div>
					</div>
					<div style="display:flex; gap:8px; flex-wrap: wrap; margin-top:6px;">
						<button class="button" id="prevBtn" disabled>ä¸Šä¸€å¤„</button>
						<button class="button" id="nextBtn" disabled>ä¸‹ä¸€å¤„</button>
						<button class="button" id="exportBtn" disabled>å¯¼å‡ºå·²é«˜äº® HTML</button>
					</div>
				</section>
				<section class="panel">
					<div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
						<div style="font-weight:600;">é«˜äº®æ¸…å•</div>
						<div class="hint" id="listHint">åŠ è½½ YAML åæ˜¾ç¤º</div>
					</div>
					<div class="list" id="quotesList"></div>
				</section>
			</aside>

			<section class="panel content">
				<article class="doc" id="doc">
					<h1>æ¬¢è¿ ğŸ‘‹</h1>
					<p>
						è¯·é€‰æ‹©å·¦ä¸Šè§’çš„ <strong>Markdown æºæ–‡ä»¶</strong> ä¸ <strong>YAML é«˜äº®æ–‡ä»¶</strong>ï¼Œ
						ç„¶åç‚¹å‡»â€œæ¸²æŸ“å¹¶é«˜äº®â€ã€‚æœ¬åº”ç”¨å°†å…ˆæ¸²æŸ“ Markdownï¼Œå†å¯¹ YAML ä¸­çš„ <em>quote</em> æ–‡æœ¬è¿›è¡Œå®šä½ä¸é«˜äº®ã€‚
					</p>
					<p class="hint">æç¤ºï¼šç¤ºä¾‹æ–‡ä»¶å¯å‚è€ƒæ‚¨æä¾›çš„ <a href="article.md" download
							title="ä¸‹è½½ç¤ºä¾‹ Markdown æ–‡æ¡£"><code>article.md</code></a> ä¸ <a href="highlight.yaml" download
							title="ä¸‹è½½ç¤ºä¾‹é«˜äº®é…ç½® YAML"><code>highlight.yaml</code></a>ã€‚</p>
				</article>
			</section>
		</main>

		<!-- footer removed -->
	</div>
	<!-- endregion -->

	<!-- region ç¬¬äºŒç« ï¼šè„šæœ¬å…¥å£ä¸åº”ç”¨éª¨æ¶ï¼ˆProgressive Disclosureï¼‰ -->
	<script>
		// region åºè¨€ï¼šä»¥ main() ä½œä¸ºé˜…è¯»å…¥å£
		function main() {
			const app = new HighlightingMarkdownApp();
			app.boot();
		}
		// æ³¨ï¼šå®é™…å¯åŠ¨ä½äºè„šæœ¬æœ«å°¾ï¼Œå¾…ç±»å®šä¹‰å®Œæˆåå†è§¦å‘ã€‚
		// endregion

		// region æ ¸å¿ƒç±»ï¼šHighlightingMarkdownAppï¼ˆä¸»æµç¨‹åè°ƒè€…ï¼‰
		class HighlightingMarkdownApp {
			constructor() {
				// æ”¶é›†å…³é”® DOM å¼•ç”¨
				this.$ = {
					mdInput: document.getElementById('mdInput'),
					yamlInput: document.getElementById('yamlInput'),
					runBtn: document.getElementById('runBtn'),
					clearBtn: document.getElementById('clearBtn'),
					prevBtn: document.getElementById('prevBtn'),
					nextBtn: document.getElementById('nextBtn'),
					exportBtn: document.getElementById('exportBtn'),
					mdName: document.getElementById('mdName'),
					yamlName: document.getElementById('yamlName'),
					doc: document.getElementById('doc'),
					docId: document.getElementById('docId'),
					docLang: document.getElementById('docLang'),
					docCreated: document.getElementById('docCreated'),
					matchStats: document.getElementById('matchStats'),
					status: document.getElementById('status'),
					quotesList: document.getElementById('quotesList'),
					listHint: document.getElementById('listHint'),
					fuzzyToggle: document.getElementById('fuzzyToggle'),
					fuzzySlider: document.getElementById('fuzzySlider'),
					fuzzyVal: document.getElementById('fuzzyVal'),
					themeToggle: document.getElementById('themeToggle'),
				};

				// å†…éƒ¨çŠ¶æ€
				this.state = {
					mdText: '',
					yamlRaw: '',
					meta: { document_id: 'â€”', language: 'â€”', created_at: 'â€”' },
					quotes: [], // {quote, confidence, index}
					marks: [], // DOM mark elements
					cursor: -1,
					fuzzyEnabled: false,
					fuzzyThreshold: 0.15,
				};
			}

			boot() {
				// é¡¶å±‚æµç¨‹ï¼šç»‘å®šäº‹ä»¶ + æŒ‰éœ€å¯ç”¨æŒ‰é’®
				this._initTheme();
				this._bindEvents();
				this._updateButtons();
				this._setStatus('å¾…å‘½ä¸­â€¦');
			}

			// region æ¨¡å—å†…ç”Ÿï¼šäº‹ä»¶ä¸äº¤äº’
			_bindEvents() {
				const { mdInput, yamlInput, runBtn, clearBtn, prevBtn, nextBtn, exportBtn, fuzzyToggle, fuzzySlider, fuzzyVal, themeToggle } = this.$;

				// ä¸»é¢˜åˆ‡æ¢
				if (themeToggle) {
					themeToggle.addEventListener('click', () => this._toggleTheme());
				}
				// æ¨¡ç³ŠåŒ¹é…å¼€å…³ & é˜ˆå€¼æ»‘å—
				const syncFuzzyUI = () => {
					if (fuzzyVal) fuzzyVal.textContent = Math.round(this.state.fuzzyThreshold * 100) + '%';
					if (fuzzySlider) fuzzySlider.disabled = !this.state.fuzzyEnabled;
					if (fuzzySlider && (fuzzySlider.value !== String(this.state.fuzzyThreshold))) {
						fuzzySlider.value = String(this.state.fuzzyThreshold);
					}
				};
				this.state.fuzzyEnabled = !!(fuzzyToggle && fuzzyToggle.checked);
				syncFuzzyUI();
				if (fuzzyToggle) {
					fuzzyToggle.addEventListener('change', () => {
						this.state.fuzzyEnabled = !!fuzzyToggle.checked;
						syncFuzzyUI();
					});
				}
				if (fuzzySlider) {
					fuzzySlider.addEventListener('input', () => {
						const v = Number(fuzzySlider.value);
						if (Number.isFinite(v)) {
							this.state.fuzzyThreshold = Math.max(0, Math.min(1.0, v));
							syncFuzzyUI();
						}
					});
				}

				mdInput.addEventListener('change', () => {
					const f = mdInput.files && mdInput.files[0];
					this.$.mdName.textContent = f ? f.name : 'æ— ';
					this._updateButtons();
				});

				yamlInput.addEventListener('change', () => {
					const f = yamlInput.files && yamlInput.files[0];
					this.$.yamlName.textContent = f ? f.name : 'æ— ';
					this._updateButtons();
				});

				runBtn.addEventListener('click', async () => {
					try {
						this._setStatus('è¯»å–æ–‡ä»¶â€¦');
						await this._loadInputs();
						this._setStatus('æ¸²æŸ“ Markdownâ€¦');
						this._renderMarkdown();
						this._setStatus('è§£æ YAMLâ€¦');
						this._parseYaml();
						this._setStatus('æ‰§è¡Œæ–‡æœ¬åŒ¹é…ä¸é«˜äº®â€¦');
						const matches = this._highlightQuotes();
						this._populateQuoteList(matches);
						this._setStatus(`å®Œæˆï¼šæˆåŠŸé«˜äº® ${matches.success} å¤„ï¼ŒæœªåŒ¹é… ${matches.missed} å¤„ã€‚`);
					} catch (err) {
						console.error(err);
						this._setStatus('é”™è¯¯ï¼š' + err.message, true);
					}
				});

				clearBtn.addEventListener('click', () => {
					this._clearHighlights();
					this._setStatus('å·²æ¸…é™¤é«˜äº®ã€‚');
				});

				prevBtn.addEventListener('click', () => this._jump(-1));
				nextBtn.addEventListener('click', () => this._jump(1));
				exportBtn.addEventListener('click', () => this._exportHighlightedHTML());
			}

			// â€”â€” ä¸»é¢˜ï¼šåˆå§‹åŒ–ã€åˆ‡æ¢ä¸æŒä¹…åŒ– â€”â€”
			_initTheme() {
				const key = 'hlr-theme';
				const saved = (() => { try { return localStorage.getItem(key); } catch { return null; } })();
				let theme = saved;
				if (!theme) {
					const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
					theme = prefersDark ? 'dark' : 'light';
				}
				this._applyTheme(theme);
				// ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–ï¼ˆæœªæ‰‹åŠ¨è®¾ç½®æ—¶æ‰è·Ÿéšï¼‰
				if (!saved && window.matchMedia) {
					try {
						window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
							this._applyTheme(e.matches ? 'dark' : 'light');
						});
					} catch { }
				}
			}

			_applyTheme(theme) {
				const html = document.documentElement;
				html.setAttribute('data-theme', theme === 'light' ? 'light' : 'dark');
				try { localStorage.setItem('hlr-theme', theme); } catch { }
			}

			_toggleTheme() {
				const html = document.documentElement;
				const cur = html.getAttribute('data-theme') || 'dark';
				const next = cur === 'light' ? 'dark' : 'light';
				this._applyTheme(next);
				// å°å‹è§†è§‰åé¦ˆ
				const btn = this.$.themeToggle;
				if (btn) {
					btn.style.transition = 'transform .18s ease';
					btn.style.transform = 'scale(0.94)';
					setTimeout(() => { btn.style.transform = 'scale(1)'; }, 180);
				}
			}

			_updateButtons() {
				const hasMd = !!(this.$.mdInput.files && this.$.mdInput.files[0]);
				const hasYaml = !!(this.$.yamlInput.files && this.$.yamlInput.files[0]);
				this.$.runBtn.disabled = !(hasMd && hasYaml);
			}

			_setStatus(text, isError = false) {
				this.$.status.textContent = text;
				this.$.status.className = isError ? 'error' : 'hint';
			}
			// endregion

			// region æ¨¡å—å†…ç”Ÿï¼šè¾“å…¥åŠ è½½ï¼ˆFileReaderï¼‰
			async _loadInputs() {
				const mdFile = this.$.mdInput.files && this.$.mdInput.files[0];
				const yamlFile = this.$.yamlInput.files && this.$.yamlInput.files[0];
				if (!mdFile || !yamlFile) throw new Error('è¯·åŒæ—¶é€‰æ‹© Markdown ä¸ YAML æ–‡ä»¶');

				const [mdText, yamlRaw] = await Promise.all([
					this._readFileText(mdFile),
					this._readFileText(yamlFile),
				]);
				this.state.mdText = mdText;
				this.state.yamlRaw = yamlRaw;
			}

			_readFileText(file) {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥: ' + file.name));
					reader.onload = () => resolve(String(reader.result || ''));
					reader.readAsText(file, 'utf-8');
				});
			}
			// endregion

			// region æ¨¡å—å†…ç”Ÿï¼šMarkdown æ¸²æŸ“ï¼ˆä¼˜å…ˆä½¿ç”¨ markedï¼Œç¦»çº¿å›é€€åˆ°å†…ç½®è§£æå™¨ï¼‰
			_renderMarkdown() {
				const md = this.state.mdText || '';
				let html;
				if (window.marked && typeof window.marked.parse === 'function') {
					// é…ç½® markedï¼šå¯ç”¨ GFMï¼Œç¦ç”¨ mangle ä»¥ä¿ç•™ä¸­æ–‡/é ASCII æ ‡é¢˜
					try { window.marked.setOptions?.({ gfm: true, breaks: false, headerIds: true, mangle: false }); } catch { }
					const raw = window.marked.parse(md);
					// è‹¥å¯ç”¨ï¼Œä½¿ç”¨ DOMPurify è¿›è¡Œå®‰å…¨æ¸…ç†
					html = (window.DOMPurify && typeof window.DOMPurify.sanitize === 'function')
						? window.DOMPurify.sanitize(raw)
						: raw;
				} else {
					// å›é€€ï¼šä½¿ç”¨å†…ç½®è½»é‡è§£æå™¨ï¼Œç¡®ä¿ç¦»çº¿å¯ç”¨
					html = this._markdownToHtml(md);
				}
				this.$.doc.innerHTML = html;
				this._clearHighlights(); // æ¸²æŸ“ä¼šé‡å»º DOMï¼Œéœ€æ¸…ç©ºæ—§é«˜äº®
			}

			_markdownToHtml(md) {
				// ç›®æ ‡ï¼šè¶³å¤Ÿè¦†ç›–å¸¸è§è¯­æ³•ï¼ˆæ ‡é¢˜ã€æ®µè½ã€åŠ ç²—ã€æ–œä½“ã€é“¾æ¥ã€è¡Œå†…ä»£ç ã€å¼•ç”¨ã€åˆ—è¡¨ã€ä»£ç å—ï¼‰
				// ç®€åŒ–ç­–ç•¥ï¼šåˆ†å—è§£æä»£ç å—ä¸æ®µè½ï¼Œè¡Œå†…å†åšæ›¿æ¢ã€‚

				// é¢„å¤„ç†ï¼šWindows æ¢è¡Œ -> \n
				md = md.replace(/\r\n?/g, '\n');

				// ä»£ç å—ï¼ˆä¸‰å¼•å·ï¼‰
				const fenceRe = /```([\s\S]*?)```/g;
				const fences = [];
				md = md.replace(fenceRe, (_, code) => {
					const i = fences.length;
					fences.push(code);
					return `\uFFF0FENCE_${i}\uFFF1`;
				});

				// è½¬ä¹‰ HTML
				const esc = (s) => s
					.replace(/&/g, '&amp;')
					.replace(/</g, '&lt;')
					.replace(/>/g, '&gt;');

				// æŒ‰æ®µè½/ç©ºè¡Œåˆ‡åˆ†
				const blocks = md.split(/\n{2,}/);
				const out = [];
				for (let block of blocks) {
					const lines = block.split(/\n/);

					// æ ‡é¢˜ #, ##, ###
					const m = /^(#{1,6})\s+(.+)$/.exec(lines[0]);
					if (m) {
						const lvl = m[1].length;
						out.push(`<h${lvl}>${this._renderInlines(m[2])}</h${lvl}>`);
						continue;
					}

					// å¼•ç”¨å—
					if (/^>\s?/.test(lines[0])) {
						const text = lines.map(l => l.replace(/^>\s?/, '')).join(' ');
						out.push(`<blockquote>${this._renderInlines(text)}</blockquote>`);
						continue;
					}

					// æ— åºåˆ—è¡¨
					if (/^\s*[-*+]\s+/.test(lines[0])) {
						const items = lines.map(l => l.replace(/^\s*[-*+]\s+/, ''));
						out.push(`<ul>${items.map(i => `<li>${this._renderInlines(i)}</li>`).join('')}</ul>`);
						continue;
					}

					// ä¿ç•™æœªçŸ¥ HTML åŒºå—ï¼ˆå¦‚ <text_content>ï¼‰
					if (/^\s*</.test(block.trim())) {
						out.push(block);
						continue;
					}

					// æ™®é€šæ®µè½
					out.push(`<p>${this._renderInlines(lines.join(' '))}</p>`);
				}

				// è¿˜åŸä»£ç å—
				let html = out.join('\n');
				html = html.replace(/\uFFF0FENCE_(\d+)\uFFF1/g, (_, i) => {
					const code = esc(fences[Number(i)] || '');
					return `<pre><code>${code}</code></pre>`;
				});

				return html;
			}

			_renderInlines(text) {
				// è¡Œå†…å…ƒç´ ï¼šå…ˆè½¬ä¹‰ï¼Œå†åšå¯Œæ–‡æœ¬æ›¿æ¢
				const esc = (s) => s
					.replace(/&/g, '&amp;')
					.replace(/</g, '&lt;')
					.replace(/>/g, '&gt;');
				let t = esc(text);

				// é“¾æ¥ [text](url)
				// æ”¯æŒè½¬ä¹‰çš„æ–¹æ‹¬å·ä¸å³æ‹¬å·ï¼šå¦‚ \[1\]ã€\)
				t = t.replace(/\[((?:\\.|[^\]])+)\]\(((?:\\.|[^)])+)\)/g, (m, txt, href) => {
					// ä»…åœ¨é“¾æ¥æ–‡æœ¬ä¸­å»æ‰å¯¹éƒ¨åˆ†æ ‡ç‚¹çš„åæ–œæ è½¬ä¹‰ï¼Œé¿å…å½±å“ä»£ç ç‰‡æ®µ
					const unesc = (s) => s.replace(/\\([\[\]\(\)`*_~!#.+\-])/g, '$1');
					return `<a href="${href}" target="_blank" rel="noreferrer noopener">${unesc(txt)}<\/a>`;
				});
				// ç²—ä½“ **text**
				t = t.replace(/\*\*([^*]+)\*\*/g, '<strong>$1<\/strong>');
				// æ–œä½“ *text* æˆ– _text_
				t = t.replace(/\*(?!\*)([^*]+)\*/g, '<em>$1<\/em>');
				t = t.replace(/_([^_]+)_/g, '<em>$1<\/em>');
				// è¡Œå†…ä»£ç  `code`
				t = t.replace(/`([^`]+)`/g, '<code>$1<\/code>');
				return t;
			}
			// endregion

			// region æ¨¡å—å†…ç”Ÿï¼šYAML è§£æï¼ˆé’ˆå¯¹ç»™å®šç»“æ„çš„è½»é‡è§£æå™¨ï¼‰
			_parseYaml() {
				// ç›®æ ‡ç»“æ„ï¼ˆç¤ºä¾‹ï¼‰ï¼š
				// schema_version: "1.0.0"
				// document_id: "456..."
				// language: "en"
				// created_at: "..."
				// results:
				//   - result:
				//       rationale: "..."
				//       quotes: "..." | ["...", "..."]
				//       confidence: 0.95
				//       gap: "..."
				const raw = this.state.yamlRaw.replace(/\r\n?/g, '\n');
				const lines = raw.split(/\n/);

				const meta = { document_id: 'â€”', language: 'â€”', created_at: 'â€”' };
				const quotes = [];
				let inResults = false;
				let current = null;
				let readingQuotes = false; // æ˜¯å¦æ­£åœ¨è¯»å–å¤šè¡Œ quotes: æ•°ç»„

				const parseValue = (v) => {
					v = v.trim();
					if (v === '') return '';
					if ((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))) {
						return v.slice(1, -1);
					}
					// å°è¯•åŸºæœ¬æ•°å­—/å¸ƒå°”
					const num = Number(v);
					if (!Number.isNaN(num)) return num;
					if (v === 'true') return true;
					if (v === 'false') return false;
					return v; // å…œåº•å­—ç¬¦ä¸²
				};

				// å°† current ä¸­çš„ quotes ç»Ÿä¸€å‹å¹³ä¸ºæ¡ç›®
				const flushCurrent = () => {
					if (!current) return;
					const conf = current.confidence ?? 1;
					const tp = current.type;
					const arr = Array.isArray(current._quotes) ? current._quotes :
						(current.quote ? [String(current.quote)] : []);
					for (const q of arr) {
						const s = String(q || '');
						if (!s) continue;
						quotes.push({ quote: s, confidence: conf, type: tp });
					}
				};

				for (let i = 0; i < lines.length; i++) {
					const line = lines[i];
					if (!line.trim()) continue;
					if (/^\s*#/.test(line)) continue; // æ³¨é‡Š

					// é¡¶å±‚é”®
					const top = /^(\w[\w_-]*):\s*(.*)$/.exec(line);
					if (top && !/^\s/.test(line)) {
						const k = top[1];
						const v = top[2];
						if (k === 'results') {
							inResults = true;
							readingQuotes = false;
							continue;
						}
						if (k in meta) meta[k] = parseValue(v);
						continue;
					}

					if (inResults) {
						// æ¡ç›®èµ·å§‹ï¼š  - result:
						if (/^\s*-\s+result:\s*$/.test(line)) {
							// æ¨é€ä¸Šä¸€ä¸ªæ¡ç›®
							flushCurrent();
							current = {};
							readingQuotes = false;
							continue;
						}

						// è‹¥åœ¨è¯»å–å¤šè¡Œ quotes æ•°ç»„ï¼Œå…ˆå°è¯•è§£æå­é¡¹ "- xxx"
						if (readingQuotes) {
							const mList = /^\s{6,}-\s*(.*)$/.exec(line);
							if (mList) {
								const val = parseValue(mList[1]);
								if (val !== undefined) {
									current._quotes = current._quotes || [];
									current._quotes.push(String(val));
								}
								continue; // ç»§ç»­è¯»å–ä¸‹ä¸€è¡Œæ•°ç»„é¡¹
							} else {
								// é€€å‡ºæ•°ç»„è¯»å–ï¼Œç»§ç»­æŒ‰å­—æ®µè§£ææœ¬è¡Œ
								readingQuotes = false;
							}
						}

						// ç»“æœå­—æ®µï¼š      key: value ï¼ˆ>=4ç©ºæ ¼ç¼©è¿›ï¼‰
						const m = /^\s{4,}([\w_-]+):\s*(.*)$/.exec(line);
						if (m && current) {
							const key = m[1];
							const rawVal = m[2];
							if (key === 'quotes') {
								// æ”¯æŒä¸‰ç§å½¢å¼ï¼š
								// 1) å†…è”æ•°ç»„ï¼šquotes: ["...", "..."]
								// 2) åˆ—è¡¨å¤šè¡Œï¼šquotes:\n      //   - "..."\n      //   - "..."
								// 3) å•å€¼ï¼šquotes: "..."
								const trimmed = rawVal.trim();
								if (trimmed === '') {
									readingQuotes = true;
									continue;
								}
								if (trimmed.startsWith('[') && trimmed.endsWith(']')) {
									// ç®€æ˜“è§£æå†…è”å­—ç¬¦ä¸²æ•°ç»„ï¼šæå–åŒå¼•å·å†…çš„å†…å®¹ï¼ˆæ”¯æŒè½¬ä¹‰ \"ï¼‰
									const items = [];
									const re = /"((?:\\\"|[^"])*)"/g;
									let mm;
									while ((mm = re.exec(trimmed))) {
										items.push(mm[1].replace(/\\\"/g, '"'));
									}
									current._quotes = items;
								} else {
									// å•è¡Œå€¼ï¼ˆæŒ‰å­—ç¬¦ä¸²å¤„ç†ï¼‰
									const v = parseValue(rawVal);
									current._quotes = [String(v)];
								}
							} else if (key === 'quote') {
								// å…¼å®¹æ—§ç‰ˆæœ¬
								const v = parseValue(rawVal);
								current._quotes = [String(v)];
							} else {
								current[key] = parseValue(rawVal);
							}
						}
					}
				}

				// æ¨é€æœ€åä¸€ä¸ªæ¡ç›®
				flushCurrent();

				this.state.meta = meta;
				// å»é‡ï¼ˆåŒä¸€ quote ä»…ä¿ç•™ä¸€æ¬¡ï¼‰
				const seen = new Set();
				this.state.quotes = quotes.filter(q => {
					const k = q.quote + '|' + q.confidence + '|' + (q.type ?? '');
					if (seen.has(k)) return false;
					seen.add(k);
					return true;
				}).map((q, i) => ({ ...q, index: i }));

				// æ˜¾ç¤ºå…ƒä¿¡æ¯
				this.$.docId.textContent = String(meta.document_id || 'â€”');
				this.$.docLang.textContent = String(meta.language || 'â€”');
				this.$.docCreated.textContent = String(meta.created_at || 'â€”');
			}
			// endregion

			// region æ¨¡å—å†…ç”Ÿï¼šæ–‡æœ¬åŒ¹é…ä¸é«˜äº®ï¼ˆè·¨èŠ‚ç‚¹åŒ¹é…ï¼‰
			_highlightQuotes() {
				const quotes = this.state.quotes || [];
				const container = this.$.doc;

				// æ”¶é›†æ‰€æœ‰ Text èŠ‚ç‚¹
				const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, {
					acceptNode: (node) => {
						if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
						const s = node.nodeValue.trim();
						if (!s) return NodeFilter.FILTER_REJECT;
						// è·³è¿‡è„šæœ¬æˆ–æ ·å¼ï¼ˆç†è®ºä¸Š doc å†…ä¸ä¼šæœ‰ï¼‰
						if (node.parentElement && ['SCRIPT', 'STYLE'].includes(node.parentElement.tagName)) {
							return NodeFilter.FILTER_REJECT;
						}
						return NodeFilter.FILTER_ACCEPT;
					}
				});

				const nodes = [];
				let n;
				while ((n = walker.nextNode())) {
					nodes.push(n);
				}

				// æ„å»ºå…¨æ–‡å­—ç¬¦ä¸²ä¸æ˜ å°„
				let full = '';
				const segments = []; // {node, start, end}
				for (const node of nodes) {
					const start = full.length;
					full += node.nodeValue;
					const end = full.length;
					segments.push({ node, start, end });
				}

				// æ ‡å‡†åŒ–å‡½æ•°ï¼ˆç”¨äºåœ¨å…¨æ–‡ä¸ quote ä¸Šåšä¸€è‡´è§„èŒƒåŒ–æœç´¢ï¼‰
				const normalize = (s) => s
					.replace(/\s+/g, ' ')            // åˆå¹¶ç©ºç™½
					.replace(/[\u2018\u2019]/g, "'") // å¼¯å¼•å· â†’ ç›´å¼•å·
					.replace(/[\u201C\u201D]/g, '"')  // å¼¯åŒå¼•å· â†’ ç›´åŒå¼•å·
					.trim();

				const normFull = normalize(full);
				// å»ºç«‹ä½ç½®æ˜ å°„ï¼šnormFull ç´¢å¼• -> full ç´¢å¼•ï¼ˆè€ƒè™‘åˆå¹¶ç©ºç™½åçš„ä½ç§»ï¼‰
				const mapIndex = [];
				{
					let iFull = 0;
					let iNorm = 0;
					while (iFull < full.length) {
						const ch = full[iFull];
						if (/\s/.test(ch)) {
							// collapse to single space: only map first in a series
							let j = iFull;
							while (j < full.length && /\s/.test(full[j])) j++;
							// æ’å…¥ä¸€ä¸ªç©ºæ ¼æ˜ å°„
							mapIndex[iNorm] = iFull; // è¿™ä¸ªç©ºæ ¼åœ¨ full çš„èµ·å§‹ä½ç½®
							iNorm += 1; // ä¸€ä¸ªç©ºæ ¼
							iFull = j;
							continue;
						}
						const ch2 = ch
							.replace(/[\u2018\u2019]/, "'")
							.replace(/[\u201C\u201D]/, '"');
						mapIndex[iNorm] = iFull;
						iNorm += ch2.length; // 1
						iFull += 1;
					}
				}

				const ranges = []; // { start,end,confidence,index,type,mode }
				let exactHit = 0, fuzzyHit = 0;
				const matchedIdx = new Set();

				// ç¬¬ä¸€è½®ï¼šç²¾ç¡®åŒ¹é…
				for (const q of quotes) {
					// å…³é”®ä¿®å¤ï¼šå½“ YAML å¼•æ–‡åŒ…å« Markdown è¡Œå†…è¯­æ³•ï¼ˆé“¾æ¥/åŠ ç²—/æ–œä½“/ä»£ç ç­‰ï¼‰æ—¶ï¼Œ
					// éœ€è¦å…ˆå°†å…¶è¿˜åŸä¸ºæ¸²æŸ“åçš„å¯è§çº¯æ–‡æœ¬å†å‚ä¸åŒ¹é…ã€‚
					const plainQ = this._mdInlineToText(String(q.quote || ''));
					const normQ = normalize(plainQ);
					if (!normQ) { continue; }
					const idx = normFull.indexOf(normQ);
					if (idx !== -1) {
						// æ˜ å°„å› full ç´¢å¼•
						const startFull = mapIndex[idx] ?? 0;
						const lastNorm = idx + normQ.length - 1;
						const endFull = (mapIndex[lastNorm] ?? (full.length - 1)) + 1; // å³å¼€åŒºé—´
						ranges.push({ start: startFull, end: endFull, confidence: Number(q.confidence || 1), index: q.index, type: q.type, mode: 'exact' });
						exactHit++;
						matchedIdx.add(q.index);
					}
				}

				// ç¬¬äºŒè½®ï¼šæ¨¡ç³ŠåŒ¹é…ï¼ˆä»…å¯¹æœªå‘½ä¸­ï¼‰
				if (this.state.fuzzyEnabled) {
					for (const q of quotes) {
						if (matchedIdx.has(q.index)) continue;
						const plainQ = this._mdInlineToText(String(q.quote || ''));
						const normQ = normalize(plainQ);
						if (!normQ) continue;
						// ä¼˜å…ˆå°è¯•â€œæ¡¥æ¥é—´éš™â€åŒ¹é…ï¼šé€‚é…æ­£æ–‡ä¸­å¤šå‡º [7] ç­‰å¼•ç”¨æ ‡æ³¨çš„æƒ…å†µ
						const gap = this._gapBridgeLocate(normFull, normQ);
						if (gap) {
							const startFull = mapIndex[gap.start] ?? 0;
							const endFull = (mapIndex[Math.max(0, gap.end - 1)] ?? (full.length - 1)) + 1;
							ranges.push({ start: startFull, end: endFull, confidence: Number(q.confidence || 1), index: q.index, type: q.type, mode: 'fuzzy' });
							fuzzyHit++;
							matchedIdx.add(q.index);
							continue;
						}
						// åŸºäºé•¿åº¦çš„åŸºç¡€é˜ˆå€¼ + æ–‡çŒ®ç¼–å· [n] çš„é¢å¤–å®¹é”™ï¼ˆæ’å…¥/åˆ é™¤ï¼‰
						let kBase = Math.ceil(normQ.length * (this.state.fuzzyThreshold || 0.15));
						let extra = 0;
						const cite = normQ.match(/\[\d+\]/g);
						if (cite) extra = cite.reduce((a, s) => a + s.length, 0); // ä¸ºå¼•ç”¨æ ‡æ³¨å­—ç¬¦é¢å¤–æ”¾å®½
						const k = Math.max(1, Math.min(64, kBase + Math.min(10, extra)));
						const hit = this._fuzzyLocate(normFull, normQ, k);
						if (hit) {
							const startFull = mapIndex[hit.start] ?? 0;
							const endFull = (mapIndex[Math.max(0, hit.end - 1)] ?? (full.length - 1)) + 1;
							ranges.push({ start: startFull, end: endFull, confidence: Number(q.confidence || 1), index: q.index, type: q.type, mode: 'fuzzy' });
							fuzzyHit++;
							matchedIdx.add(q.index);
						}
					}
				}

				const missed = quotes.length - matchedIdx.size;

				// æ ¹æ®èµ·å§‹ä½ç½®ä»åå¾€å‰å¤„ç†ï¼Œé¿å…æ‹†åˆ†å½±å“åç»­åç§»
				ranges.sort((a, b) => b.start - a.start || b.end - a.end);

				const marks = [];
				for (const r of ranges) {
					// å°†åŒºé—´æ˜ å°„åˆ°å…·ä½“èŠ‚ç‚¹
					const affected = this._locateNodes(segments, r.start, r.end);
					if (!affected.length) continue;

					// å¯¹æ¯ä¸ªèŠ‚ç‚¹è¿›è¡Œåˆ‡åˆ†ä¸åŒ…è£¹
					for (let k = affected.length - 1; k >= 0; k--) {
						const part = affected[k]; // { node, from, to } ç›¸å¯¹è¯¥ node çš„åç§»
						const mark = this._wrapRangeInNode(part.node, part.from, part.to, r.confidence, r.index, r.type, r.mode || 'exact');
						if (mark) marks.push(mark);
					}
				}

				this.state.marks = marks.reverse(); // è‡ªç„¶é¡ºåº
				const totalHit = exactHit + fuzzyHit;
				this.$.matchStats.textContent = `å‘½ä¸­ ${totalHit}ï¼ˆç²¾ç¡® ${exactHit} / æ¨¡ç³Š ${fuzzyHit}ï¼‰ Â· æœªåŒ¹é… ${missed}`;
				this.$.prevBtn.disabled = this.state.marks.length === 0;
				this.$.nextBtn.disabled = this.state.marks.length === 0;
				this.$.exportBtn.disabled = this.state.marks.length === 0;
				this.state.cursor = this.state.marks.length ? 0 : -1;
				if (this.state.cursor >= 0) this._scrollToMark(this.state.marks[0]);

				return { success: totalHit, missed, exact: exactHit, fuzzy: fuzzyHit };
			}

			_locateNodes(segments, startFull, endFull) {
				// è¿”å›å—å½±å“çš„èŠ‚ç‚¹ä¸åœ¨è¯¥èŠ‚ç‚¹çš„å±€éƒ¨åç§»
				const res = [];
				for (const seg of segments) {
					if (seg.end <= startFull) continue;
					if (seg.start >= endFull) break;
					const s = Math.max(0, startFull - seg.start);
					const e = Math.min(seg.end - seg.start, endFull - seg.start);
					res.push({ node: seg.node, from: s, to: e });
				}
				return res;
			}

			_wrapRangeInNode(node, from, to, confidence, idx, type, mode = 'exact') {
				// åœ¨å•ä¸ª Text èŠ‚ç‚¹ä¸­ï¼Œå°† [from, to) åŒ…è£¹ä¸º <mark>
				try {
					let t = node;
					if (from > 0) t = t.splitText(from);
					if (to - from < t.nodeValue.length) t.splitText(to - from);
					const mark = document.createElement('mark');
					mark.className = 'hl';
					// æ ¹æ®ç½®ä¿¡åº¦è°ƒèŠ‚èƒŒæ™¯é€æ˜åº¦ï¼ˆ0.4~0.85ï¼‰ï¼Œå¹¶æŒ‰ç±»å‹ç€è‰²
					const alpha = Math.max(0.35, Math.min(0.85, 0.35 + 0.5 * Number(confidence || 1)));
					mark.style.background = this._colorForType(type, alpha);
					mark.dataset.index = String(idx);
					mark.dataset.mode = String(mode || 'exact');
					if (type) mark.dataset.type = String(type);
					t.parentNode.replaceChild(mark, t);
					mark.appendChild(t);
					return mark;
				} catch (e) {
					console.warn('wrap failed', e);
					return null;
				}
			}

			// åŸºäºç±»å‹çš„ 26 è‰²è°ƒè‰²ç›˜ï¼ˆé€šè¿‡å“ˆå¸Œæ˜ å°„åˆ° 0..25 æ¡¶ï¼Œè¿”å› hsla é¢œè‰²å­—ç¬¦ä¸²ï¼‰
			_colorForType(type, alpha = 0.6) {
				if (!type) return `rgba(255, 238, 153, ${alpha})`; // æ— ç±»å‹å›é€€åˆ°é»˜è®¤é»„
				const buckets = 26;
				const idx = ((this._hashStr(String(type).toLowerCase().trim()) % buckets) + buckets) % buckets;
				const hue = Math.round(idx * (360 / buckets));
				return `hsla(${hue}, 80%, 65%, ${alpha})`;
			}

			_hashStr(s) {
				// djb2 ç®€åŒ–ç‰ˆ
				let h = 5381;
				for (let i = 0; i < s.length; i++) h = ((h << 5) + h) + s.charCodeAt(i);
				return h >>> 0; // æ— ç¬¦å·
			}

			_clearHighlights() {
				// è¿˜åŸæ‰€æœ‰ mark
				const { doc } = this.$;
				const marks = Array.from(doc.querySelectorAll('mark.hl'));
				for (const m of marks) {
					const txt = document.createTextNode(m.textContent || '');
					m.parentNode.replaceChild(txt, m);
				}
				this.state.marks = [];
				this.state.cursor = -1;
				this.$.matchStats.textContent = 'â€”';
				this.$.prevBtn.disabled = true;
				this.$.nextBtn.disabled = true;
				this.$.exportBtn.disabled = true;
				this._renderQuoteList([]);
			}
			// endregion

			// region æ¨¡å—å†…ç”Ÿï¼šä¾§æ æ¸…å•ä¸å¯¼èˆª
			_populateQuoteList(matches) {
				const modeByIdx = new Map();
				for (const m of this.state.marks) {
					const idx = Number(m.dataset.index);
					if (!modeByIdx.has(idx)) modeByIdx.set(idx, String(m.dataset.mode || 'exact'));
				}
				const listData = this.state.quotes.map(q => ({
					quote: q.quote,
					type: q.type,
					confidence: q.confidence,
					index: q.index,
					matched: modeByIdx.has(q.index),
					mode: modeByIdx.get(q.index) || null,
				}));
				this._renderQuoteList(listData);
			}

			_renderQuoteList(items) {
				const { quotesList, listHint } = this.$;
				quotesList.innerHTML = '';
				if (!items || !items.length) {
					listHint.textContent = 'æš‚æ— é«˜äº®é¡¹';
					return;
				}
				listHint.textContent = `å…± ${items.length} æ¡`;
				for (const it of items) {
					const el = document.createElement('div');
					el.className = 'quote-item';
					const color = this._colorForType(it.type, 0.9);
					const matchedBadge = it.matched
						? (it.mode === 'fuzzy' ? '<span class="badge">æ¨¡ç³ŠåŒ¹é…</span>' : '<span class="badge">ç²¾ç¡®åŒ¹é…</span>')
						: (this.state.fuzzyEnabled ? '<span class="badge">æœªæ¨¡ç³ŠåŒ¹é…</span>' : '<span class="badge">æœªå¯ç”¨æ¨¡ç³Š</span>');
					el.innerHTML = `
								<div class="q"><span class="dot" style="background:${color}"></span> ${this._escapeHtml(it.quote)}</div>
								<div class="sub">
									<span class="badge"><span class="dot" style="background:${color}"></span> ${this._escapeHtml(it.type || 'æœªæ ‡æ³¨')}</span>
									Â· ç½®ä¿¡åº¦: ${Number(it.confidence).toFixed(2)} Â· ${it.matched ? '<span class="ok">å·²åŒ¹é…</span>' : '<span class="error">æœªåŒ¹é…</span>'} Â· ${matchedBadge}
								</div>
								<div class="actions">
									<button class="button" data-act="locate" data-idx="${it.index}">å®šä½</button>
									<button class="button" data-act="copy" data-idx="${it.index}">å¤åˆ¶å¼•æ–‡</button>
								</div>
							`;
					el.addEventListener('click', (e) => {
						const btn = e.target.closest('button');
						if (!btn) return;
						const idx = Number(btn.dataset.idx);
						if (btn.dataset.act === 'locate') this._locateByIndex(idx);
						if (btn.dataset.act === 'copy') this._copyQuoteByIndex(idx);
					});
					quotesList.appendChild(el);
				}
			}

			_locateByIndex(idx) {
				const pos = this.state.marks.findIndex(m => Number(m.dataset.index) === idx);
				if (pos >= 0) {
					this.state.cursor = pos;
					this._scrollToMark(this.state.marks[pos], true);
				} else {
					this._setStatus('æœªæ‰¾åˆ°å¯¹åº”çš„é«˜äº®ä½ç½®ã€‚');
				}
			}

			async _copyQuoteByIndex(idx) {
				const item = this.state.quotes.find(q => q.index === idx);
				if (!item) return;
				try {
					await navigator.clipboard.writeText(item.quote);
					this._setStatus('å·²å¤åˆ¶å¼•æ–‡åˆ°å‰ªè´´æ¿ã€‚');
				} catch {
					this._setStatus('å¤åˆ¶å¤±è´¥ï¼šæµè§ˆå™¨æƒé™é™åˆ¶ã€‚', true);
				}
			}

			_jump(delta) {
				if (!this.state.marks.length) return;
				this.state.cursor = (this.state.cursor + delta + this.state.marks.length) % this.state.marks.length;
				this._scrollToMark(this.state.marks[this.state.cursor], true);
			}

			_scrollToMark(mark, flash = false) {
				// ä½¿ç”¨çª—å£æ»šåŠ¨ï¼Œé¿å…å†…å±‚æ»šåŠ¨å®¹å™¨åœ¨ Chrome ä¸­å‡ºç°çš„è¶Šç•Œé—®é¢˜
				const headerOffset = 84; // ä¸æ ·å¼ä¸­çš„ scroll-margin-top ä¿æŒä¸€è‡´
				const rect = mark.getBoundingClientRect();
				const absoluteTop = window.scrollY + rect.top;
				const targetTop = Math.max(0, absoluteTop - headerOffset);
				window.scrollTo({ top: targetTop, behavior: 'smooth' });
				if (flash) this._flash(mark);
			}

			_flash(el) {
				el.style.transition = 'box-shadow 0.8s ease';
				el.style.boxShadow = '0 0 0 4px rgba(124, 192, 255, 0.5)';
				setTimeout(() => { el.style.boxShadow = 'none'; }, 800);
			}

			_exportHighlightedHTML() {
				const html = `<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n<meta charset="UTF-8"/>\n<title>å·²é«˜äº®å¯¼å‡º</title>\n<style>mark{background:#ffee99;color:#242424;padding:1px 0;border-radius:4px;}</style>\n</head>\n<body>${this.$.doc.outerHTML}</body>\n</html>`;
				const blob = new Blob([html], { type: 'text/html;charset=utf-8' });
				const a = document.createElement('a');
				a.href = URL.createObjectURL(blob);
				a.download = 'highlighted.html';
				document.body.appendChild(a);
				a.click();
				a.remove();
			}
			// endregion

			// region å·¥å…·æ–¹æ³•ï¼ˆå±€éƒ¨ã€ç´§é‚»ä½¿ç”¨è€…ï¼‰
			_escapeHtml(s) {
				return String(s)
					.replace(/&/g, '&amp;')
					.replace(/</g, '&lt;')
					.replace(/>/g, '&gt;');
			}

			// åœ¨æ¨¡å¼ä¸­æœªåŒ…å«å¼•ç”¨æ ‡æ³¨è€Œæ­£æ–‡ä¸­åŒ…å«æ—¶ï¼Œå…è®¸åœ¨å·¦å³é”šç‚¹ä¹‹é—´å­˜åœ¨å°æ®µç¼ºå£
			_gapBridgeLocate(text, pattern) {
				const m = pattern.length;
				if (m < 6) return null;
				// è‹¥æ¨¡å¼è‡ªèº«åŒ…å« [n]ï¼Œä¼˜å…ˆæŒ‰å¼•ç”¨ä½ç½®åˆ†å‰²
				const citeRe = /\[(\d+)\]/;
				let splitAt = -1, citeLen = 0;
				{
					const mm = pattern.match(citeRe);
					if (mm && mm.index !== undefined) { splitAt = mm.index; citeLen = mm[0].length; }
				}
				let left, right;
				if (splitAt >= 0) {
					left = pattern.slice(0, splitAt);
					right = pattern.slice(splitAt + citeLen);
				} else {
					// å¦åˆ™æŒ‰ä¸­é—´åˆ†å‰²ï¼Œå–å·¦å³é”šç‚¹
					const leftLen = Math.max(4, Math.min(16, Math.floor(m * 0.35)));
					const rightLen = Math.max(4, Math.min(16, Math.floor(m * 0.35)));
					left = pattern.slice(0, leftLen);
					right = pattern.slice(m - rightLen);
				}
				if (!left || !right) return null;
				// åœ¨å…¨æ–‡ä¸­å¯»æ‰¾å·¦é”šå‡ºç°ä½ç½®ï¼Œæ•°é‡é™åˆ¶
				const positions = [];
				let i = 0;
				while (positions.length < 20) {
					const p = text.indexOf(left, i);
					if (p === -1) break;
					positions.push(p);
					i = p + 1;
				}
				if (!positions.length) return null;
				const maxGap = Math.max(24, Math.min(160, Math.floor(pattern.length * 0.8))); // è‡ªé€‚åº”å…è®¸çš„é—´éš™é•¿åº¦
				for (const p of positions) {
					const after = p + left.length;
					const q = text.indexOf(right, after);
					if (q === -1) continue;
					const between = text.slice(after, q);
					if (between.length <= maxGap) {
						// ä¼˜å…ˆï¼šé—´éš™ä¸­åŒ…å«å¼•ç”¨æ ‡è®° [æ•°å­—]
						if (/\[\d+\]/.test(between) || /\s{0,}[,ï¼Œã€]{0,1}\s{0,}/.test(between)) {
							return { start: p, end: q + right.length };
						}
					}
				}
				return null;
			}

			// â€”â€” æ¨¡ç³ŠåŒ¹é…è¾…åŠ©ï¼šä»…å¯¹æœªç²¾ç¡®å‘½ä¸­çš„æ¡ç›®è¿›è¡Œå›é€€ â€”â€”
			_fuzzyLocate(normFull, normQ, k) {
				const n = normFull.length, m = normQ.length;
				if (!n || !m) return null;
				const positions = this._collectFuzzyCandidates(normFull, normQ);
				let best = null;
				for (const pos of positions) {
					const res = this._approxMatchAround(normFull, normQ, k, pos);
					if (res && (!best || res.cost < best.cost)) best = res;
					if (best && best.cost === 0) break;
				}
				return best; // {start,end,cost} in norm space
			}

			_collectFuzzyCandidates(text, pattern) {
				const m = pattern.length;
				let anchorLen = Math.max(4, Math.min(20, Math.ceil(m * 0.3)));
				const pushAll = (needle, max = 20) => {
					const list = [];
					if (!needle) return list;
					let i = 0, cnt = 0;
					while (cnt < max) {
						const idx = text.indexOf(needle, i);
						if (idx === -1) break;
						list.push(idx);
						i = idx + 1;
						cnt++;
					}
					return list;
				};
				const set = new Set();
				const add = (arr) => arr.forEach(x => set.add(x));
				let tried = 0;
				while (set.size === 0 && anchorLen >= 3 && tried < 3) {
					add(pushAll(pattern.slice(0, anchorLen)));
					add(pushAll(pattern.slice(Math.max(0, m - anchorLen))));
					anchorLen = Math.max(3, Math.floor(anchorLen / 2));
					tried++;
				}
				if (set.size === 0) {
					const step = Math.max(1, Math.floor(text.length / 10));
					for (let i = 0; i < text.length; i += step) set.add(i);
				}
				return Array.from(set).slice(0, 30);
			}

			_approxMatchAround(text, pattern, k, pos) {
				const n = text.length, m = pattern.length;
				const pad = Math.ceil(m * 0.5) + k + 8;
				const winStart = Math.max(0, pos - pad);
				const winEnd = Math.min(n, pos + pad);
				const win = text.slice(winStart, winEnd);
				const W = win.length;
				if (W === 0) return null;
				// æ„å»ºå®Œæ•´ DP çŸ©é˜µï¼Œä¾¿äºå›æº¯ç²¾å‡†èµ·ç‚¹ï¼ˆSellers å±€éƒ¨å¯¹é½ï¼‰
				const dp = new Array(W + 1);
				for (let i = 0; i <= W; i++) dp[i] = new Array(m + 1);
				for (let j = 0; j <= m; j++) dp[0][j] = j; // æ¨¡å¼å‰ç¼€æˆæœ¬
				for (let i = 1; i <= W; i++) dp[i][0] = 0; // å±€éƒ¨åŒ¹é…ï¼šå…è®¸ä»»æ„èµ·ç‚¹
				let bestCost = Infinity, bestEnd = -1;
				for (let i = 1; i <= W; i++) {
					const chT = win.charCodeAt(i - 1);
					let rowMin = dp[i][0];
					for (let j = 1; j <= m; j++) {
						const chP = pattern.charCodeAt(j - 1);
						const sub = dp[i - 1][j - 1] + (chT === chP ? 0 : 1);
						const ins = dp[i][j - 1] + 1;
						const del = dp[i - 1][j] + 1;
						const v = sub < ins ? (sub < del ? sub : del) : (ins < del ? ins : del);
						dp[i][j] = v;
						if (v < rowMin) rowMin = v;
					}
					if (dp[i][m] < bestCost) { bestCost = dp[i][m]; bestEnd = i; }
				}
				if (bestCost > k || bestEnd < 0) return null;
				// å›æº¯è·å–ç²¾å‡†èµ·ç‚¹
				let i = bestEnd, j = m;
				while (j > 0 && i > 0) {
					const chT = win.charCodeAt(i - 1);
					const chP = pattern.charCodeAt(j - 1);
					const costSub = (chT === chP ? 0 : 1);
					if (dp[i][j] === dp[i - 1][j - 1] + costSub) { i--; j--; continue; }
					if (dp[i][j] === dp[i - 1][j] + 1) { i--; continue; }
					// else from left
					j--;
				}
				const startIdx = winStart + i;
				const endIdx = winStart + bestEnd;
				return { start: startIdx, end: endIdx, cost: bestCost };
			}

			// å°† Markdown è¡Œå†…è¯­æ³•ï¼ˆé“¾æ¥ã€å¼ºè°ƒã€ä»£ç ã€åˆ é™¤çº¿ã€å›¾åƒã€å¼•ç”¨å¼é“¾æ¥ã€è‡ªåŠ¨é“¾æ¥ç­‰ï¼‰
			// è½¬æ¢ä¸ºæ¸²æŸ“åçš„å¯è§çº¯æ–‡æœ¬ï¼Œä¾¿äºä¸ DOM æ–‡æœ¬åŒ¹é…ã€‚
			_mdInlineToText(input) {
				let s = String(input || '');
				// ç»Ÿä¸€æ¢è¡Œ
				s = s.replace(/\r\n?/g, '\n');
				// ä»£ç å—å›´æ ï¼ˆ```lang\n...```ï¼‰â€”â€”å°½é‡ä¿ç•™å†…éƒ¨æ–‡æœ¬ï¼Œå»æ‰å›´æ ä¸å¯é€‰è¯­è¨€æ ‡æ³¨
				s = s.replace(/```[\t ]*([a-zA-Z0-9_+-]+)?\n([\s\S]*?)```/g, '$2');
				// è¡Œå†…ä»£ç  `code`
				s = s.replace(/`([^`]+)`/g, '$1');
				// è¡Œå†…é“¾æ¥ [text](url "title") â†’ textï¼ˆæ”¯æŒè½¬ä¹‰æ–¹æ‹¬å·/å³æ‹¬å·ï¼‰
				s = s.replace(/\[((?:\\.|[^\]])+)\]\((?:\\.|[^)])+\)/g, '$1');
				// å¼•ç”¨å¼é“¾æ¥ [text][ref] â†’ text
				s = s.replace(/\[([^\]]+)\]\[[^\]]+\]/g, '$1');
				// å›¾ç‰‡ ![alt](src) â†’ altï¼ˆè‹¥æ—  alt åˆ™æ¸…ç©ºï¼‰
				s = s.replace(/!\[([^\]]*)\]\((?:[^)]+)\)/g, '$1');
				// å¼ºè°ƒ/åŠ ç²—/ç²—æ–œä½“
				s = s.replace(/\*\*([^*]+)\*\*/g, '$1');
				s = s.replace(/__([^_]+)__/g, '$1');
				s = s.replace(/\*(?!\*)([^*]+)\*/g, '$1');
				s = s.replace(/_([^_]+)_/g, '$1');
				// åˆ é™¤çº¿
				s = s.replace(/~~([^~]+)~~/g, '$1');
				// è‡ªåŠ¨é“¾æ¥ <http://example.com> â†’ http://example.com
				s = s.replace(/<([a-zA-Z][^>\s]+)>/g, '$1');
				// å†…è” HTML æ ‡ç­¾å»é™¤ï¼Œä»…ä¿ç•™æ–‡æœ¬
				s = s.replace(/<\/?[^>]+>/g, '');
				// åæ–œæ è½¬ä¹‰ï¼ˆ\* \_ ç­‰ï¼‰å»æ‰è½¬ä¹‰ç¬¦
				s = s.replace(/\\([*_`~\[\]()>#+\-])/g, '$1');
				// åˆå¹¶ç©ºç™½
				s = s.replace(/\s+/g, ' ').trim();
				return s;
			}
			// endregion
		}
		// endregion

		// region å°¾å£°ï¼šå¯åŠ¨ç¨‹åºï¼ˆç¡®ä¿ç±»å·²å®šä¹‰åæ‰§è¡Œï¼‰
		window.addEventListener('DOMContentLoaded', main);
		// endregion
	</script>
	<!-- endregion -->
</body>

</html>